/**
 * NTP_PPP_GENERATOR
 * 
 * 9 May 2020
 * 
 * This program connect the NTP-PPS board to a time server, and continually sends out PPS and ZDA pulses every second.
 * 
 * It uses the Adafruit SSD1306 library, and any of it's dependencies.
 * 
 */

#include <Arduino.h>
#include <WiFi.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <string>
#include <vector>
#include <AsyncUDP.h>

#include "secrets.h"

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels

#define OLED_RESET     -1 // Reset pin # (or -1 if sharing Arduino reset pin)
#define SCREEN_ADDRESS 0x3D ///< See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

const char* ntpServer = "pool.ntp.org";
const long  gmtOffset_sec = 0;
const int   daylightOffset_sec = 0;

const int PPS_OUT_PIN = 17; //actually gpio 17, but I'm using the DOIT definitions.
const int PPS_OUT_LED = 16;

const int TCP_PORT = 5555;
const int UDP_PORT = 5556;

#define LOGO_HEIGHT   63  
#define LOGO_WIDTH    128

static const unsigned char PROGMEM logo_bmp[] =
{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x01, 0xa0, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x02, 0x80, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x04, 0x40, 0x00, 0x00, 
0x00, 0x00, 0x08, 0x04, 0x01, 0xc0, 0x18, 0x10, 0x10, 0x03, 0x80, 0x38, 0x05, 0x40, 0x00, 0x00, 
0x00, 0x00, 0x1c, 0x0c, 0x07, 0xf0, 0x18, 0x30, 0x38, 0x0f, 0xe0, 0x1c, 0x08, 0x40, 0x00, 0x00, 
0x00, 0x00, 0x0e, 0x1c, 0x0f, 0xf8, 0x1c, 0x70, 0x38, 0x1f, 0xc0, 0x1e, 0x12, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x0e, 0x18, 0x1c, 0x1c, 0x0e, 0x60, 0x38, 0x18, 0x00, 0x1f, 0x20, 0x80, 0x00, 0x00, 
0x00, 0x00, 0x06, 0x38, 0x1c, 0x1c, 0x06, 0xe0, 0x38, 0x1c, 0x00, 0x0f, 0xa4, 0x80, 0x00, 0x00, 
0x00, 0x00, 0x07, 0x30, 0x18, 0x0c, 0x07, 0xc0, 0x38, 0x1f, 0xc0, 0x0f, 0xc4, 0x80, 0x00, 0x00, 
0x00, 0x00, 0x03, 0x70, 0x18, 0x0c, 0x03, 0x80, 0x38, 0x07, 0xe0, 0x0f, 0xe8, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x03, 0xe0, 0x1c, 0x1c, 0x03, 0x80, 0x38, 0x00, 0xe0, 0x07, 0xf1, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x03, 0xe0, 0x1e, 0x3c, 0x03, 0x80, 0x38, 0x10, 0x60, 0x07, 0xf9, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0xe0, 0x0f, 0xf8, 0x03, 0x80, 0x38, 0x1f, 0xe0, 0x07, 0xfd, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0xc0, 0x07, 0xe0, 0x03, 0x80, 0x30, 0x1f, 0xc0, 0x03, 0xfe, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

hw_timer_t * timer = NULL;
portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;

volatile time_t rawtime;
volatile bool second_changed;
char ip_address [16];

WiFiServer server (TCP_PORT);
AsyncUDP udp;
std::vector <WiFiClient> tcp_clients;


/**
 * Generate ZDA String
 */
String generateZDA() {
  struct tm * timeinfo =  localtime (const_cast<time_t*>(&rawtime));
  String zda_string;
  zda_string.reserve(50);
  char buf[50];
  sprintf(buf, "$GPZDA,%02d%02d%02d.000,%02d,%02d,%04d,00,00*", 
                  timeinfo->tm_hour, 
                  timeinfo->tm_min, 
                  timeinfo->tm_sec,
                  timeinfo->tm_mday,
                  timeinfo->tm_mon+1,
                  timeinfo->tm_year + 1900);
  zda_string = String(buf);
  size_t zda_length (zda_string.length());

  uint8_t checksum = 0;
  for (auto i = 0; i<zda_length; ++i) {
    checksum = checksum ^ buf[i];
  }

  char checkbuf[3];
  sprintf(checkbuf, "%02X", checksum);

  zda_string += checksum;
  //zda_string += "\n";
  
  return zda_string;
}

/**
 * Method for updating the display.
 */
void printLocalTime()
{
  display.clearDisplay();
  display.setCursor(0, 0);
  struct tm * timeinfo =  localtime (const_cast<time_t*>(&rawtime));
  display.println(timeinfo, "%A, %B %d %Y\n   %H:%M:%S UTC\n\n");
  display.println("IP Address: ");
  display.println(ip_address);
  display.print("Pnorts: \nTCP: ");
  display.print(String(TCP_PORT).c_str());
  display.print(" UDP: ");
  display.println(String(UDP_PORT).c_str());
  display.display();

  String zda_string = generateZDA();
  Serial.println(zda_string.c_str());
  udp.broadcastTo(zda_string.c_str(), UDP_PORT);
  for (auto it = tcp_clients.begin(); it != tcp_clients.end(); ++it) {
    if (it->connected()) {
      it->println(zda_string.c_str());
    } else {
      tcp_clients.erase(it);
      --it;
    }
  }
}


/**
 * Interrupt handler for the 1s interrupt.
 */
void IRAM_ATTR onTimer() {
  portENTER_CRITICAL_ISR(&timerMux);
  rawtime += 1; 
  digitalWrite(PPS_OUT_PIN, HIGH);
  digitalWrite(PPS_OUT_LED, HIGH);
  second_changed = true;
  portEXIT_CRITICAL_ISR(&timerMux);
}

void setup() {
  Serial.begin(115200);
  Wire.setClock(400000);
  pinMode(PPS_OUT_PIN, OUTPUT);
  pinMode(PPS_OUT_LED, OUTPUT);

  //Set up screen.
  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if(!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;); // Don't proceed, loop forever
  }
  display.clearDisplay();
  // Show initial display buffer contents on the screen --
  display.drawBitmap(0, 0, logo_bmp, LOGO_WIDTH, LOGO_HEIGHT, 1);
  display.display();
  delay(2000); // Pause for 2 seconds
  
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor (25, 0);
  //display.setSize(2);
  display.println ("VOYIS NTP PPS");
  display.setCursor (21, 8);
  display.println ("Generator V1.0");
  display.display ();
  display.printf("\nConnecting to %s\n", WIFI_SSID);
  display.display();
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  while (WiFi.status() != WL_CONNECTED) {
      delay(500);
      display.print(".");
      display.display();
  }
  Serial.println(" CONNECTED");
  IPAddress ip_temp = WiFi.localIP();
  sprintf(ip_address, "%d.%d.%d.%d", ip_temp[0], ip_temp[1], ip_temp[2], ip_temp[3] );
  display.display();
  
  //init and get the time
  struct tm timeinfo;
  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
  if(!getLocalTime(&timeinfo)){
    display.println("Failed to obtain time");
    return;
  }
  rawtime = mktime (&timeinfo);

  timer = timerBegin(0, 80, true);
  timerAttachInterrupt(timer, &onTimer, true);
  timerAlarmWrite(timer, 1000000, true);
  timerAlarmEnable(timer);
  
  //disconnect WiFi as it's no longer needed
  //WiFi.disconnect(true);
  //WiFi.mode(WIFI_OFF);
  delay(2000);
  display.clearDisplay();

  server.begin();
}

void loop() {
  // put your main code here, to run repeatedly:
  if (second_changed) {
    second_changed = false;
    printLocalTime();
    delay(100);
    digitalWrite(PPS_OUT_PIN, LOW);
    digitalWrite(PPS_OUT_LED, LOW);
  }

  WiFiClient client = server.available();
  if (client) {
    tcp_clients.push_back(client);
  }

  delay(1);
  
}
